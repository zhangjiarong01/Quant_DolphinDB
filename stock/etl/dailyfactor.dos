stock_daily_prev = loadTable("dfs://stock_daily_prev", "stock_daily_prev")
stock_daily_basic = loadTable("dfs://stock_daily_basic", "stock_daily_basic")

// è®¾ç½®èµ·æ­¢æ—¶é—´
startDate = 2015.01.01
endDate = 2025.01.01

// æ„é€ preparedè¡¨
dataTmp = select
ts_code, trade_date, close, pct_chg, (next(close) - close) / close as forward_returns,//åŸºæœ¬
turnover_rate, turnover_rate_f, volume_ratio, // æµåŠ¨æ€§
pe_ttm, pb, // ä¼°å€¼
float_share, total_mv // è§„æ¨¡
from ej(stock_daily_prev, stock_daily_basic, `ts_code`trade_date)
where trade_date between startDate and endDate, close > 0, total_mv > 10
context by ts_code
csort trade_date
order by ts_code, trade_date;


// å­˜å‚¨preparedè¡¨
// æ­£ç¡®å†™æ³•ï¼šæ£€æŸ¥æ•°æ®åº“æ˜¯å¦å­˜åœ¨ï¼Œå­˜åœ¨åˆ™åˆ é™¤
if(existsDatabase("dfs://stock_daily_prepared")) {
    dropDatabase("dfs://stock_daily_prepared")
}
years = 1990..2090 
jan1Dates = date(string(years) + ".01.01")  // è½¬æ¢ä¸ºæ—¥æœŸç±»å‹
create database "dfs://stock_daily_prepared" PARTITIONED BY VALUE(jan1Dates)


colnames = ["ts_code","trade_date","close","pct_chg","forward_returns","turnover_rate","turnover_rate_f","volume_ratio","pe_ttm","pb","float_share","total_mv"]
coltypes = ["SYMBOL","DATE","DOUBLE","DOUBLE","DOUBLE","DOUBLE","DOUBLE","DOUBLE","DOUBLE","DOUBLE","DOUBLE","DOUBLE"]
Schema = table(1:0,colnames, coltypes)
db = database("dfs://stock_daily_prepared")
stock_daily_prepared = createPartitionedTable(dbHandle=db, table=Schema, tableName=`stock_daily_prepared, partitionColumns=`trade_date)


setColumnComment( stock_daily_prepared, {
    ts_code           : "è‚¡ç¥¨ä»£ç ï¼ˆæ ¼å¼ï¼šXXXXXX.SZ/SHï¼‰",
    trade_date        : "äº¤æ˜“æ—¥æœŸï¼ˆæ ¼å¼ï¼šYYYYMMDDï¼‰",
    close             : "æ”¶ç›˜ä»·",
    pct_chg           : "æ¶¨è·Œå¹…ï¼ˆ%ï¼‰",
    forward_returns   : "æœªæ¥æ”¶ç›Šç‡ï¼ˆå¦‚1æ—¥ï¼šnext(close)/close - 1ï¼‰",
    turnover_rate     : "æ¢æ‰‹ç‡ï¼ˆ%ï¼‰ï¼Œåæ˜ æˆäº¤æ´»è·ƒåº¦",
    turnover_rate_f   : "æ¢æ‰‹ç‡ï¼ˆè‡ªç”±æµé€šè‚¡å£å¾„ï¼‰",
    volume_ratio      : "é‡æ¯”ï¼ˆå½“å‰æˆäº¤é‡ä¸è¿‡å»å‡é‡æ¯”å€¼ï¼‰",
    pe_ttm            : "å¸‚ç›ˆç‡ï¼ˆTTMï¼ŒåŠ¨æ€ï¼‰",
    pb                : "å¸‚å‡€ç‡ï¼ˆPrice / Bookï¼‰",
    float_share       : "æµé€šè‚¡æœ¬ï¼ˆä¸‡è‚¡ï¼‰",
    total_mv          : "æ€»å¸‚å€¼ï¼ˆä¸‡å…ƒï¼‰"
})


// Get unique years from the data
uniqueYears = exec distinct year(trade_date) from dataTmp order by year(trade_date)

// Append data by year
for(year in uniqueYears) {
    yearData = select * from dataTmp where year(trade_date) == year
    loadTable("dfs://stock_daily_prepared", "stock_daily_prepared").append!(yearData)
}








// ====================================å› å­è®¡ç®—éƒ¨åˆ†
// ç®€å•Nä¸ªæœˆæ”¶ç›Šç‡å› å­
def return_Nm(close, N){
    // è®¡ç®—Nä¸ªæœˆæ”¶ç›Šç‡
    // å‡è®¾æ•°æ®æ˜¯æ—¥é¢‘çš„ï¼Œæ¯æœˆå¤§çº¦21ä¸ªäº¤æ˜“æ—¥
    tradingDays = 21 * N
    return (close - move(close, tradingDays)) / move(close, tradingDays)
}

// æ¢æ‰‹ç‡åŠ æƒæ”¶ç›Šç‡å› å­
def wgt_return_Nm(close, turnover_rate, N){
    // è®¡ç®—Nä¸ªæœˆæ¢æ‰‹ç‡åŠ æƒæ”¶ç›Šç‡
    tradingDays = 21 * N
    daily_ret = ratios(close) - 1  // è®¡ç®—æ¯æ—¥æ”¶ç›Šç‡
    wgt_ret = mavg(daily_ret * turnover_rate, tradingDays) / mavg(turnover_rate, tradingDays)
    return wgt_ret
}

// æŒ‡æ•°è¡°å‡åŠ æƒæ”¶ç›Šç‡å› å­
def exp_wgt_return_Nm(close, turnover_rate, N){
    // ä½¿ç”¨DolphinDBå†…ç½®çš„ewmaå‡½æ•°ä¼˜åŒ–å®ç°
    tradingDays = 21 * N
    daily_ret = ratios(close) - 1
    // è®¡ç®—æŒ‡æ•°è¡°å‡æƒé‡ (alpha=1/N)
    alpha = 1.0 / N
    weighted_ret = ewmMean(daily_ret * turnover_rate, alpha) / ewmMean(turnover_rate, alpha)
    
    return weighted_ret
}

// 1. BPå› å­ (è´¦é¢å¸‚å€¼æ¯”) - å¯ç›´æ¥å®ç°
def BP(pb){
    // BP = 1/PB (å‡€èµ„äº§/æ€»å¸‚å€¼)
    return 1.0 / pb
}

// 2. EPå› å­ (ç›ˆåˆ©å¸‚å€¼æ¯”) - å˜é€šå®ç°
def EP(pe_ttm){
    // EP = 1/PE (å‡€åˆ©æ¶¦(TTM)/æ€»å¸‚å€¼)
    return 1.0 / pe_ttm
}

// 3. ç»¼åˆä¼°å€¼å› å­
def Value_Composite(pe_ttm, pb){
    // ç»“åˆEPå’ŒBPçš„ç»¼åˆä¼°å€¼å› å­
    ep = 1.0 / pe_ttm
    bp = 1.0 / pb
    return (ep + bp) / 2
}


// Nä¸ªæœˆæ—¥å‡æ¢æ‰‹ç‡å› å­
def turn_Nm(turnover_rate, N){
    // è®¡ç®—æœ€è¿‘Nä¸ªæœˆ(çº¦21*Nä¸ªäº¤æ˜“æ—¥)çš„æ—¥å‡æ¢æ‰‹ç‡
    tradingDays = 21 * N
    return mavg(turnover_rate, tradingDays)
}

// Nä¸ªæœˆæ¢æ‰‹ç‡æ ‡å‡†å·®å› å­
def std_turn_Nm(turnover_rate, N){
    tradingDays = 21 * N
    return mstd(turnover_rate, tradingDays)
}

// Nä¸ªæœˆæ”¶ç›Šç‡æ ‡å‡†å·®å› å­
def std_Nm(pct_chg, N){
    // è®¡ç®—æœ€è¿‘Nä¸ªæœˆ(çº¦21*Nä¸ªäº¤æ˜“æ—¥)çš„æ”¶ç›Šç‡æ ‡å‡†å·®
    tradingDays = 21 * N
    return mstd(pct_chg, tradingDays)
}








def factorcalculate(data, factorName, factorParameter, startDate, endDate){
    /*
    * Description: An example of how to create factor template through meta programming

    * :param data: TABLE or Table Handler, data source 
    * :param factorName: STRING, factor's name
    * :param factorParameter: STRING, factor's parameters, "open,close,high,low"
    * :param startDate: DATE, start date of data
    * :param endDate: DATE, end date of data

    * :return ret: TABLE, calculated factor value
    */

    //step1: Split factor parameter into string vector
    args = ((factorParameter.strReplace(" ","")).split(","))

    //step2: Create sql columns of parameters
    args = each(sqlCol, args)

    //step3: Create 'select' part
    selects = (sqlCol( `ts_code), sqlCol(`trade_date),
                sqlColAlias(makeUnifiedCall(funcByName("string"), factorName), "factorname"),
                sqlColAlias(makeUnifiedCall(funcByName(factorName), args),"value"))
    
    //step4: Create 'from' part
    from_tb = data

    //step5: Create 'where' part
    whereConditions = expr(startDate, <=, sqlCol(`trade_date), <=, endDate)
    
    //step6: Create 'context by' part
    groupcols = sqlCol(`ts_code)

    //step7: Create sql statement and execute it
    ret = sql(
        select = selects,
        from = from_tb,
        where = whereConditions,
        groupBy = groupcols,
        groupFlag = 0 //context by
        ).eval()
    
    return ret
}



// çµæ´»åˆ†æå› å­å€¼

factorvalue = 
select
    ts_code,
    trade_date,

    return_Nm(pct_chg, 1) as return_1m,
    return_Nm(pct_chg, 3) as return_3m,
    wgt_return_Nm(close, turnover_rate, 1) as wgt_return_1m,
    wgt_return_Nm(close, turnover_rate, 3) as wgt_return_3m,

    exp_wgt_return_Nm(close, turnover_rate, 1) as exp_wgt_return_1m,
    exp_wgt_return_Nm(close, turnover_rate, 3) as exp_wgt_return_3m,

    turn_Nm(turnover_rate, 1) as turn_1m,
    turn_Nm(turnover_rate, 3) as turn_3m,

    std_turn_Nm(turnover_rate, 1) as std_turn_1m,
    std_turn_Nm(turnover_rate, 3) as std_turn_3m,

    std_Nm(pct_chg, 1) as std_1m,
    std_Nm(pct_chg, 3) as std_3m,

    1.0 / pb as BP,
    1.0 / pe_ttm as EP,
    (1.0 / pb + 1.0 / pe_ttm) / 2 as BPnEP

from loadTable("dfs://stock_daily_prepared", "stock_daily_prepared")
where trade_date between startDate and endDate
context by ts_code;


// // é¦–å…ˆè®¡ç®—æ¯ä¸ªå› å­åœ¨æ¯ä¸ªæ—¥æœŸçš„ç¼ºå¤±æ•°é‡
// missingStats = select 
//     trade_date,
//     count(*) as total_count,
//     sum(iif(isNull(return_1m), 1, 0)) as missing_return_1m,
//     sum(iif(isNull(return_3m), 1, 0)) as missing_return_3m,
//     sum(iif(isNull(wgt_return_1m), 1, 0)) as missing_wgt_return_1m,
//     sum(iif(isNull(wgt_return_3m), 1, 0)) as missing_wgt_return_3m,
//     sum(iif(isNull(exp_wgt_return_1m), 1, 0)) as missing_exp_wgt_return_1m,
//     sum(iif(isNull(exp_wgt_return_3m), 1, 0)) as missing_exp_wgt_return_3m,
//     sum(iif(isNull(turn_1m), 1, 0)) as missing_turn_1m,
//     sum(iif(isNull(turn_3m), 1, 0)) as missing_turn_3m,
//     sum(iif(isNull(std_turn_1m), 1, 0)) as missing_std_turn_1m,
//     sum(iif(isNull(std_turn_3m), 1, 0)) as missing_std_turn_3m,
//     sum(iif(isNull(std_1m), 1, 0)) as missing_std_1m,
//     sum(iif(isNull(std_3m), 1, 0)) as missing_std_3m,
//     sum(iif(isNull(BP), 1, 0)) as missing_BP,
//     sum(iif(isNull(EP), 1, 0)) as missing_EP,
//     sum(iif(isNull(BPnEP), 1, 0)) as missing_BPnEP
// from factorvalue
// group by trade_date

// // è®¡ç®—ç¼ºå¤±æ¯”ä¾‹(%)å¹¶æ ¼å¼åŒ–è¾“å‡º
// missingRatio = select 
//     trade_date,
//     total_count,
//     missing_return_1m * 100.0 / total_count as return_1m_missing_ratio,
//     missing_return_3m * 100.0 / total_count as return_3m_missing_ratio,
//     missing_wgt_return_1m * 100.0 / total_count as wgt_return_1m_missing_ratio,
//     missing_wgt_return_3m * 100.0 / total_count as wgt_return_3m_missing_ratio,
//     missing_exp_wgt_return_1m * 100.0 / total_count as exp_wgt_return_1m_missing_ratio,
//     missing_exp_wgt_return_3m * 100.0 / total_count as exp_wgt_return_3m_missing_ratio,
//     missing_turn_1m * 100.0 / total_count as turn_1m_missing_ratio,
//     missing_turn_3m * 100.0 / total_count as turn_3m_missing_ratio,
//     missing_std_turn_1m * 100.0 / total_count as std_turn_1m_missing_ratio,
//     missing_std_turn_3m * 100.0 / total_count as std_turn_3m_missing_ratio,
//     missing_std_1m * 100.0 / total_count as std_1m_missing_ratio,
//     missing_std_3m * 100.0 / total_count as std_3m_missing_ratio,
//     missing_BP * 100.0 / total_count as BP_missing_ratio,
//     missing_EP * 100.0 / total_count as EP_missing_ratio,
//     missing_BPnEP * 100.0 / total_count as BPnEP_missing_ratio
// from missingStats

// missingRatio.columnNames()
// // ç»˜åˆ¶ç¼ºå¤±æ¯”ä¾‹éšæ—¶é—´å˜åŒ–å›¾
// plot(
//     missingRatio[missingRatio.columnNames()[2:]],
// )





//ç”¨ å½“æ—¥ä¸­ä½æ•° å¡«å…… EP NULL å€¼
factorTB =  factorvalue
update factorTB set
    EP = iif(isNull(EP), median(EP), EP),
    BPnEP = iif(isNull(BPnEP), median(BPnEP), BPnEP)
context by trade_date

// æ£€éªŒæ¯ä¸ªå› å­åœ¨æ¯ä¸ªæ—¥æœŸçš„ç¼ºå¤±æ•°é‡
missingStats = select 
    trade_date,
    count(*) as total_count,
    sum(iif(isNull(return_1m), 1, 0)) as missing_return_1m,
    sum(iif(isNull(return_3m), 1, 0)) as missing_return_3m,
    sum(iif(isNull(wgt_return_1m), 1, 0)) as missing_wgt_return_1m,
    sum(iif(isNull(wgt_return_3m), 1, 0)) as missing_wgt_return_3m,
    sum(iif(isNull(exp_wgt_return_1m), 1, 0)) as missing_exp_wgt_return_1m,
    sum(iif(isNull(exp_wgt_return_3m), 1, 0)) as missing_exp_wgt_return_3m,
    sum(iif(isNull(turn_1m), 1, 0)) as missing_turn_1m,
    sum(iif(isNull(turn_3m), 1, 0)) as missing_turn_3m,
    sum(iif(isNull(std_turn_1m), 1, 0)) as missing_std_turn_1m,
    sum(iif(isNull(std_turn_3m), 1, 0)) as missing_std_turn_3m,
    sum(iif(isNull(std_1m), 1, 0)) as missing_std_1m,
    sum(iif(isNull(std_3m), 1, 0)) as missing_std_3m,
    sum(iif(isNull(BP), 1, 0)) as missing_BP,
    sum(iif(isNull(EP), 1, 0)) as missing_EP,
    sum(iif(isNull(BPnEP), 1, 0)) as missing_BPnEP
from factorTB
group by trade_date

// è®¡ç®—ç¼ºå¤±æ¯”ä¾‹(%)å¹¶æ ¼å¼åŒ–è¾“å‡º
missingRatio = select 
    trade_date,
    total_count,
    missing_return_1m * 100.0 / total_count as return_1m_missing_ratio,
    missing_return_3m * 100.0 / total_count as return_3m_missing_ratio,
    missing_wgt_return_1m * 100.0 / total_count as wgt_return_1m_missing_ratio,
    missing_wgt_return_3m * 100.0 / total_count as wgt_return_3m_missing_ratio,
    missing_exp_wgt_return_1m * 100.0 / total_count as exp_wgt_return_1m_missing_ratio,
    missing_exp_wgt_return_3m * 100.0 / total_count as exp_wgt_return_3m_missing_ratio,
    missing_turn_1m * 100.0 / total_count as turn_1m_missing_ratio,
    missing_turn_3m * 100.0 / total_count as turn_3m_missing_ratio,
    missing_std_turn_1m * 100.0 / total_count as std_turn_1m_missing_ratio,
    missing_std_turn_3m * 100.0 / total_count as std_turn_3m_missing_ratio,
    missing_std_1m * 100.0 / total_count as std_1m_missing_ratio,
    missing_std_3m * 100.0 / total_count as std_3m_missing_ratio,
    missing_BP * 100.0 / total_count as BP_missing_ratio,
    missing_EP * 100.0 / total_count as EP_missing_ratio,
    missing_BPnEP * 100.0 / total_count as BPnEP_missing_ratio
from missingStats

missingRatio.columnNames()
// ç»˜åˆ¶ç¼ºå¤±æ¯”ä¾‹éšæ—¶é—´å˜åŒ–å›¾
plot(
    missingRatio[missingRatio.columnNames()[2:]],
)



// medianStats = select
//     trade_date,
//     median(return_1m) as median_return_1m,
//     median(return_3m) as median_return_3m,
//     median(wgt_return_1m) as median_wgt_return_1m,
//     median(wgt_return_3m) as median_wgt_return_3m,
//     median(exp_wgt_return_1m) as median_exp_wgt_return_1m,
//     median(exp_wgt_return_3m) as median_exp_wgt_return_3m,
//     median(turn_1m) as median_turn_1m,
//     median(turn_3m) as median_turn_3m,
//     median(std_turn_1m) as median_std_turn_1m,
//     median(std_turn_3m) as median_std_turn_3m,
//     median(std_1m) as median_std_1m,
//     median(std_3m) as median_std_3m,
//     median(BP) as median_BP,
//     median(EP) as median_EP,
//     median(BPnEP) as median_BPnEP
// from factorvalue
// group by trade_date

// plot(
//     medianStats[medianStats.columnNames()[2:]],
// )

// maxStats = select
//     trade_date,
//     max(return_1m) as max_return_1m,
//     max(return_3m) as max_return_3m,
//     max(wgt_return_1m) as max_wgt_return_1m,
//     max(wgt_return_3m) as max_wgt_return_3m,
//     max(exp_wgt_return_1m) as max_exp_wgt_return_1m,
//     max(exp_wgt_return_3m) as max_exp_wgt_return_3m,
//     max(turn_1m) as max_turn_1m,
//     max(turn_3m) as max_turn_3m,
//     max(std_turn_1m) as max_std_turn_1m,
//     max(std_turn_3m) as max_std_turn_3m,
//     max(std_1m) as max_std_1m,
//     max(std_3m) as max_std_3m,
//     max(BP) as max_BP,
//     max(EP) as max_EP,
//     max(BPnEP) as max_BPnEP
// from factorvalue
// group by trade_date


// plot(
//     maxStats[maxStats.columnNames()[2:]],
// )



// minStats = select
//     trade_date,
//     min(return_1m) as min_return_1m,
//     min(return_3m) as min_return_3m,
//     min(wgt_return_1m) as min_wgt_return_1m,
//     min(wgt_return_3m) as min_wgt_return_3m,
//     min(exp_wgt_return_1m) as min_exp_wgt_return_1m,
//     min(exp_wgt_return_3m) as min_exp_wgt_return_3m,
//     min(turn_1m) as min_turn_1m,
//     min(turn_3m) as min_turn_3m,
//     min(std_turn_1m) as min_std_turn_1m,
//     min(std_turn_3m) as min_std_turn_3m,
//     min(std_1m) as min_std_1m,
//     min(std_3m) as min_std_3m,
//     min(BP) as min_BP,
//     min(EP) as min_EP,
//     min(BPnEP) as min_BPnEP
// from factorvalue
// group by trade_date

// plot(
//     minStats[minStats.columnNames()[2:]],
// )


//å»æå€¼
def removeOutlier(x){
    l = quantile(x, 0.01)
    u = min(quantile(x, 0.99), 10)  // ç¡¬é™åˆ¶
    return iif(x > u, u, iif(x < l, l, x))
}

def generateOutlierSQL(colName){
    return "removeOutlier(" + colName + ") as " + colName
}

def factorRemoveOutlier(factorTB){
    factorNames = factorTB.columnNames()[2:]
    selectText1 = "select ts_code,trade_date,"
    selectText2 = concat(each(generateOutlierSQL, factorNames), ", ")
    selectText3 = " from factorTB context by trade_date" 
    sqlText = selectText1 + selectText2 +selectText3
    result = parseExpr(sqlText).eval()
    return result
}

//è°ƒç”¨å‡½æ•°
factorTB = factorRemoveOutlier(factorTB)

//æ ‡å‡†åŒ–
def generateStdSQL(colName){
    return "zscore(" + colName + ") as " + colName
}

def factorStandardize(factorTB){
    factorNames = factorTB.columnNames()[2:]
    selectText1 = "select ts_code,trade_date,"
    selectText2 = concat(each(generateStdSQL, factorNames), ", ")
    selectText3 = " from factorTB context by trade_date" 
    sqlText = selectText1 + selectText2 +selectText3
    result = parseExpr(sqlText).eval()
    return result
}

//è°ƒç”¨å‡½æ•°
factorTB = factorStandardize(factorTB)



// æ£€æŸ¥æ ‡å‡†åŒ–çš„æ•ˆæœ
maxStats = select
    trade_date,
    max(return_1m) as max_return_1m,
    max(return_3m) as max_return_3m,
    max(wgt_return_1m) as max_wgt_return_1m,
    max(wgt_return_3m) as max_wgt_return_3m,
    max(exp_wgt_return_1m) as max_exp_wgt_return_1m,
    max(exp_wgt_return_3m) as max_exp_wgt_return_3m,
    max(turn_1m) as max_turn_1m,
    max(turn_3m) as max_turn_3m,
    max(std_turn_1m) as max_std_turn_1m,
    max(std_turn_3m) as max_std_turn_3m,
    max(std_1m) as max_std_1m,
    max(std_3m) as max_std_3m,
    max(BP) as max_BP,
    max(EP) as max_EP,
    max(BPnEP) as max_BPnEP
from factorTB
group by trade_date


plot(
    maxStats[maxStats.columnNames()[2:]],
    maxStats[maxStats.columnNames()[0]]
)


minStats = select
    trade_date,
    min(return_1m) as min_return_1m,
    min(return_3m) as min_return_3m,
    min(wgt_return_1m) as min_wgt_return_1m,
    min(wgt_return_3m) as min_wgt_return_3m,
    min(exp_wgt_return_1m) as min_exp_wgt_return_1m,
    min(exp_wgt_return_3m) as min_exp_wgt_return_3m,
    min(turn_1m) as min_turn_1m,
    min(turn_3m) as min_turn_3m,
    min(std_turn_1m) as min_std_turn_1m,
    min(std_turn_3m) as min_std_turn_3m,
    min(std_1m) as min_std_1m,
    min(std_3m) as min_std_3m,
    min(BP) as min_BP,
    min(EP) as min_EP,
    min(BPnEP) as min_BPnEP
from factorTB
group by trade_date

plot(
    minStats[minStats.columnNames()[2:]],
)

medianStats = select
    trade_date,
    median(return_1m) as median_return_1m,
    median(return_3m) as median_return_3m,
    median(wgt_return_1m) as median_wgt_return_1m,
    median(wgt_return_3m) as median_wgt_return_3m,
    median(exp_wgt_return_1m) as median_exp_wgt_return_1m,
    median(exp_wgt_return_3m) as median_exp_wgt_return_3m,
    median(turn_1m) as median_turn_1m,
    median(turn_3m) as median_turn_3m,
    median(std_turn_1m) as median_std_turn_1m,
    median(std_turn_3m) as median_std_turn_3m,
    median(std_1m) as median_std_1m,
    median(std_3m) as median_std_3m,
    median(BP) as median_BP,
    median(EP) as median_EP,
    median(BPnEP) as median_BPnEP
from factorTB
group by trade_date

plot(
    medianStats[medianStats.columnNames()[2:]],
)


// == å»ºå› å­åº“è¡¨ ==
if(existsDatabase("dfs://stock_daily_factor")) {
    dropDatabase("dfs://stock_daily_factor")
}
years = 1990..2090 
jan1Dates = date(string(years) + ".01.01")  // è½¬æ¢ä¸ºæ—¥æœŸç±»å‹
create database "dfs://stock_daily_factor" PARTITIONED BY VALUE(jan1Dates)


colnames = ["ts_code","trade_date","factorname","value"]
coltypes = ["SYMBOL","DATE","STRING","DOUBLE"]
Schema = table(1:0,colnames, coltypes)
db = database("dfs://stock_daily_factor")
factortb = createPartitionedTable(dbHandle=db, table=Schema, tableName=`stock_daily_factor, partitionColumns=`trade_date)


// å­˜å‚¨åˆ°çª„è¡¨
factorTB.columnNames()[2:]
factorTBnarrow = unpivot(factorTB, `ts_code`trade_date, factorTB.columnNames()[2:])

// åˆ†æ‰¹å­˜å‚¨
uniqueMonths = select distinct year(trade_date) as year, month(trade_date) as month 
              from factorTBnarrow 
              order by year, month

for(row in uniqueMonths) {
    year = row.year
    month = row.month
    monthData = select * from factorTBnarrow where 
                year(trade_date) == year and 
                month(trade_date) == month
    loadTable("dfs://stock_daily_factor", "stock_daily_factor").append!(monthData)
}


//ç›¸å…³æ€§
factorTB = select value from loadTable("dfs://stock_daily_factor","stock_daily_factor") pivot by ts_code,trade_date,factorname

factorCorrMatrix = corrMatrix(matrix(factorTB[:,2:]))



//å¯¼å…¥ Alphalens å•å› å­è¯„ä»·åŠŸèƒ½æ¨¡å—
use alphalens

//å•ç‹¬åˆ†æ
factor =
    select trade_date as date, ts_code.string() as sym, value
    from loadTable("dfs://stock_daily_factor","stock_daily_factor")
    where factorname = `return_1m;


price =
    select close
    from loadTable("dfs://stock_daily_prepared","stock_daily_prepared")
    pivot by trade_date as date, ts_code.string() as sym;


factorData = get_clean_factor_and_forward_returns(factor,price,periods=[1,5,10])

infTearSheet = create_information_tear_sheet(
                factorData,
                group_neutral=false,
                by_group=false)
icMean = rowAvg(infTearSheet.Information_Analysis[1,1:])
icPvalue = rowAvg(infTearSheet.Information_Analysis[5,1:])

ReturnSheet = create_returns_tear_sheet(
                factorData,
                group_neutral=false,
                by_group=false)
ReturnSheet.cumulative_returns_by_quantile_1


// === æ‰¹é‡åˆ†æ ===
factorNames = schema(factorTB).colDefs.name[2:]
factorNames = `turn_1m
// === åˆ›å»ºå› å­è¯„ä»·æŒ‡æ ‡è¡¨ ===
factorReport = table(100:0, `factor`ic_mean`ic_std`ic_sharpe, [STRING, DOUBLE, DOUBLE, DOUBLE])
factor5Return = table(100:0, `date`factor`C1`C2`C3`C4`C5`C6, [DATE, STRING, DOUBLE, DOUBLE, DOUBLE,DOUBLE, DOUBLE, DOUBLE])


for (fname in factorNames) {
    print("ğŸ” æ­£åœ¨æµ‹è¯•å› å­ï¼š" + fname$STRING)
    sqlText1 = "select trade_date as date, ts_code as sym, "
    sqlText2 = " as value from factorTB"
    sqlText = sqlText1 + fname + sqlText2
    factor = parseExpr(sqlText).eval()

    try {
        factorData = get_clean_factor_and_forward_returns(factor, price, quantiles=5, periods=[1,5,10])
        ICSheet= create_information_tear_sheet(factor_data=factorData, group_neutral=false, by_group=false)
        ic_mean = ICSheet.Information_Analysis[1,2]
        ic_std = ICSheet.Information_Analysis[4,2]
        ic_sharpe = ICSheet.Information_Analysis[2,2]
        print("æ’å…¥å› å­æŠ¥å‘Šï¼š" + fname)
        insert into factorReport values(fname, ic_mean, ic_std, ic_sharpe)
        ReturnSheet = create_returns_tear_sheet(
                factorData,
                group_neutral=false,
                by_group=false)
        cumulative_returns_by_quantile_1 = select  date, fname, C1,C2,C3,C4,C5,C6 from ReturnSheet.cumulative_returns_by_quantile_1
        print("æ’å…¥åˆ†å±‚ç»Ÿè®¡ï¼š" + fname)
        factor5Return.append!(cumulative_returns_by_quantile_1)
    } catch (ex) {
        print("âŒ å› å­å¤±è´¥ï¼š" + fname$STRING)
    }
}






share(factorReport,`factorReportshare)
share(factor5Return,`factor5Returnshare)

plotwgt_return_1m = select * from factor5Returnshare where factor = `wgt_return_1m
plotBP = select * from factor5Returnshare where factor = `BP
plotstd_turn_1m = select * from factor5Returnshare where factor = `std_turn_1m
plotturn_1m = select * from factor5Returnshare where factor = `turn_1m

plot(plotBP[`C1`C2`C3`C4`C5],plotBP[`date]  )
plot(plotstd_turn_1m[`C1`C2`C3`C4`C5],plotstd_turn_1m[`date]  )
plot(plotwgt_return_1m[`C1`C2`C3`C4`C5],plotwgt_return_1m[`date]  )
plot(plotturn_1m[`C1`C2`C3`C4`C5],plotturn_1m[`date]  )






















// çº¿æ€§é¢„æµ‹
testDate = 2024.01.01
traindata = select * from multifactorTB where trade_date<testDate
testdata = select * from multifactorTB where trade_date>testDate
poWeights = ols(traindata.forward_returns, traindata[:, 5:])
signalTBOLS = select ts_code, trade_date, close, forward_returns, dot(matrix(testdata[:, 5:]),poWeights[1:]).flatten() as signal_port from testdata
corr(signalTBOLS.forward_returns, signalTBOLS.signal_port)
share signalTBOLS as signalTBOLSS


// xgboosté¢„æµ‹
try{loadPlugin("xgboost")}catch(ex){}
Y = exec forward_returns from traindata
X = traindata[:, 5:]
// è®¾ç½®å‚æ•°
params = {
    "objective": "reg:squarederror", // å›å½’ä»»åŠ¡ï¼Œä½¿ç”¨å¹³æ–¹è¯¯å·®ç›®æ ‡å‡½æ•°
    "max_depth": 7,                  // æ ‘çš„æœ€å¤§æ·±åº¦
    "eta": 0.05,                      // å­¦ä¹ ç‡
    "subsample": 0.9,                // æ¯æ£µæ ‘ä½¿ç”¨çš„æ ·æœ¬æ¯”ä¾‹
    "colsample_bytree": 0.8,         // æ¯æ£µæ ‘ä½¿ç”¨çš„ç‰¹å¾æ¯”ä¾‹
    "min_child_weight": 1,           // å¶å­èŠ‚ç‚¹æœ€å°æ ·æœ¬æƒé‡å’Œ
    "gamma": 0,                      // èŠ‚ç‚¹åˆ†è£‚æ‰€éœ€çš„æœ€å°æŸå¤±å‡å°‘å€¼
    "lambda": 1,                     // L2 æ­£åˆ™åŒ–é¡¹
    "alpha": 0,                      // L1 æ­£åˆ™åŒ–é¡¹
    "eval_metric": "rmse"            // å›å½’ä»»åŠ¡çš„è¯„ä¼°æŒ‡æ ‡ï¼ˆå‡æ–¹æ ¹è¯¯å·®ï¼‰
}

// è®­ç»ƒæ¨¡å‹ï¼Œé¢„æµ‹å¹¶è®¡ç®—å‡†ç¡®ç‡ï¼š
model = xgboost::train(Y, X, params)
// æ”¯æŒå°†æ¨¡å‹æŒä¹…åŒ–ï¼ˆä¾¿äºä¹‹ååŠ è½½å·²æœ‰æ¨¡å‹ï¼‰
xgboost::saveModel(model, "AStockXgboost001.mdl")
// åŠ è½½å·²æœ‰æ¨¡å‹
model = xgboost::loadModel("AStockXgboost001.mdl")
// åˆæˆå› å­å€¼
signal_port = xgboost::predict(model, testdata[:, 5:])
// å› å­å€¼æ ‡å‡†åŒ–
signal_port = (signal_port - mean(signal_port)) / (std(signal_port))
// åˆå¹¶å› å­å€¼
signalTBXG = select ts_code, trade_date, close, forward_returns, 
    signal_port as signal_port from testdata

corr(signalTBXG.forward_returns, signalTBXG.signal_port)
share signalTBXG as signalTBXGS




// ç­–ç•¥å›æµ‹æ¨¡å—
try{loadPlugin("MatchingEngineSimulator")
loadPlugin("Backtest")}
catch(ex){}
go

stockAdj = select * from loadTable('dfs://stock_daily_prev', 'stock_daily_prev') where trade_date>=2018.01.01

data0 = lj(signalTBXGS,stockAdj,`ts_code`trade_date)


// é€‰å–åŸå§‹æ•°æ®ï¼Œå¹¶ç”Ÿæˆæ¯ä¸€å¤©æ¯åªç¥¨å› å­å€¼çš„æ’åï¼ˆç”±å¤§åˆ°å°ï¼‰
m = select *,signal_port as factor_value, rank(signal_port, false) as rank from data0 
where (ts_code like '%.SZ' or ts_code like '%.SH') and trade_date <= 2025.02.01
context by trade_date 
// å‡è®¾è‚¡ç¥¨æŒä»“ä¸ªæ•°ä¸º 30 
holdingNum = 30
// å‰”é™¤ä¸æ¶‰åŠçš„è‚¡ç¥¨
stockList = exec distinct(ts_code) from m where rank < holdingNum
m = select * from m where ts_code in stockList
// æ„å»ºæ¯æ—¥çš„è¡Œæƒ…+ä¿¡å·è¡¨messageBar
messageBar = select ts_code as symbol, concatDateTime(trade_date, 15:00:00.000) as tradeTime, open as open, low as low, high as high, close as close,
100*vol$LONG as volume, 100*int(vol/close)$DOUBLE as amount, 0.0 as upLimitPrice, 0.0 as downLimitPrice, 
open as prevClose, fixedLengthArrayVector([rank,factor_value]).double() as signal
from m


// ç”¨äºonbarå‡½æ•°å†…å°†msgç”±dictè½¬ä¸ºtable
def flattenmsg(msgdict){
    symbolList = each(x -> x["symbol"], values(msgdict))
    timeList = each(x -> x["tradeTime"], values(msgdict))
    openList = each(x -> x["open"], values(msgdict))
    lowList = each(x -> x["low"], values(msgdict))
    highList = each(x -> x["high"], values(msgdict))
    closeList = each(x -> x["close"], values(msgdict))
    volumeList = each(x -> x["volume"], values(msgdict))
    amountList = each(x -> x["amount"], values(msgdict))
    uplimitList = each(x -> x["upLimitPrice"], values(msgdict))
    downlimitList = each(x -> x["downLimitPrice"], values(msgdict))
    prevCloseList = each(x -> x["prevClosePrice"], values(msgdict))
    signal1List = each(x -> x["signal"][0], values(msgdict))
    signal2List = each(x -> x["signal"][1], values(msgdict))
    // æ„é€ è¡¨
    msgtable = table(
        symbolList as `symbol,
        timeList as `tradeTime,
        openList as `open,
        lowList as `low,
        highList as `high,
        closeList as `close,
        volumeList as `volume,
        amountList as `amount,
        uplimitList as `upLimitPrice,
        downlimitList as `downLimitPrice,
        prevCloseList as `prevClosePrice,
        signal1List as `signal1,
        signal2List as `signal2
    )
    return msgtable
}

// åˆå§‹åŒ–å‡½æ•°ï¼Œåˆ›å»ºå¼•æ“æ—¶æ‰§è¡Œ
def initialize(mutable context){
    context['signalTableExist'] = 0
    context['holdingTableExist'] = 0
}

// æ¯æ—¥è¡Œæƒ…å‰æ‰§è¡Œ
def beforeTrading(mutable context){
    print ("beforeTrading: "+context["tradeDate"])
}

// æ¯åˆ°è¾¾æ—¥é¢‘æ•°æ®æ—¶é—´ç‚¹æ‰§è¡Œï¼ˆ15ï¼š00ï¼‰
def onBar(mutable context, msg, indicator=null){
    msgTable = flattenmsg(msg)
    // print("msgè½¬åŒ–ä¸ºtable")
    thisDate = context["tradeDate"]
    // print("ä»Šå¤©æ—¥æœŸ"+thisDate)
    
    // 1.æ ¹æ®æ“ä½œè¡¨ï¼Œç»“åˆå¼€ç›˜ï¼Œæ‰§è¡Œä¿¡å·
    if(context['signalTableExist'] == 1 and dayOfMonth(thisDate)== 1){
        signalTable = context['signalTable']
        //print("Exist Signal table")
        if(context['holdingTableExist'] == 1){
            // æ ¹æ®ï¼ˆä¸Šä¸€å¤©ï¼‰ä¿¡å·è¡¨ï¼Œç»“åˆå½“å‰æŒä»“ï¼Œå…ˆæŠŠå½“å‰æŒæœ‰çš„ä¿¡å·å°äº0çš„è‚¡ç¥¨å–å‡º
            holdingTable = Backtest::getPosition(context["engine"])
            //print("Exist holding table")
            holdingTable = select context["tradeTime"], symbol, longPosition from holdingTable where longPosition > 0;
            // å¾—åˆ°æŒæœ‰è‚¡ç¥¨çš„åˆ—
            holdingStock = exec symbol from holdingTable
            // å¾—åˆ°éœ€è¦å–å‡ºçš„è‚¡ç¥¨åˆ—
            allShort = exec symbol from signalTable where rank > context['holdingNum']
            // å¾—åˆ°éœ€è¦å¹³ä»“çš„è‚¡ç¥¨åˆ—
            toCloseList = holdingStock[holdingStock in allShort]
            // å¹³ä»“ä¸ªæ•°
            toCloseNum = size(allShort)
            // print("å‡†å¤‡å¹³ä»“ä¸ªæ•°"+toCloseNum)
            if(toCloseNum > 0){
                // å¹³ä»“
                toCloseTable = select symbol, longPosition from holdingTable where symbol in toCloseList
                orderMsg = select symbol, concatDateTime(thisDate, 09:00:00.000), 0, open, longPosition, 3 from lj(copy(toCloseTable), copy(msgTable), `symbol) where  longPosition >= 100 and date(tradeTime) == thisDate and open is not null and open != close
                Backtest::submitOrder(context["engine"], orderMsg,"sell")
                // print("å®é™…å¹³ä»“ä¸ªæ•°"+size(orderMsg))
            }
            availableCash = Backtest::getAvailableCash(context["engine"])
            holdingTable = Backtest::getPosition(context["engine"])
            toBuyTable = select * from signalTable where  rank < context['holdingNum']
            toLongNum = size(toBuyTable)
            //print("å‡†å¤‡ä¹°å…¥ä¸ªæ•°"+toLongNum)
            if(toLongNum > 0){
                // ä¹°å…¥
                toBuyTable = select symbol, 100*int((availableCash*value)\sum(value)\close\1000) as amount, open, close from lj(toBuyTable, msgTable, `symbol) where date(tradeTime) = thisDate;
                orderMsg = select symbol, concatDateTime(thisDate, 10:00:00.000), 0, open, amount, 1 from toBuyTable where amount >=100 and open is not null and open != close
                Backtest::submitOrder(context["engine"], orderMsg,"buy")
                //print("å®é™…ä¹°å…¥ä¸ªæ•°"+size(orderMsg))
            
            }

            holdingTable = Backtest::getPosition(context["engine"])
            holdingStock = exec symbol from holdingTable
            holdgNum = size(holdingStock)
            //print("ç›®å‰æŒæœ‰"+holdgNum)
        }
        else{
            // æ— æŒä»“çš„åˆå§‹æƒ…å†µï¼Œä¹°å…¥
            // print("Not Exist holding table")
            availableCash = Backtest::getAvailableCash(context["engine"])
            // print(availableCash)
            signalTable = context['signalTable']
            toBuyList = exec symbol, value from signalTable where rank < context['holdingNum']
            toLongNum = size(toBuyList)
            //print("å‡†å¤‡ä¹°å…¥ä¸ªæ•°"+toLongNum)
            toBuyList = select symbol, 100*int((availableCash*value)\sum(value)\close\1000) as amount, open, close from lj(toBuyList, msgTable, `symbol) where date(tradeTime) = thisDate;
            orderMsg = select symbol, concatDateTime(thisDate, 10:00:00.000), 0, open, amount, 1 from toBuyList where amount >=100 and open is not null and open != close
            // éœ€è¦åŠ å…¥open != closeï¼Œæ²¡æœ‰è€ƒè™‘æ¶¨åœæ¿ä¸å¯ä¹°å…¥çš„é—®é¢˜ï¼Œå›æµ‹æ”¶ç›Šä¼šè™šé«˜ã€‚
            Backtest::submitOrder(context["engine"], orderMsg,"buy")
            //print("å®é™…ä¹°å…¥ä¸ªæ•°"+size(orderMsg))

            // æ›´æ–°æŒä»“è¡¨ï¼ˆä¸‹ä¸€å¤©æä¾›ç»™beforeTradingï¼‰
            holdingTable = Backtest::getPosition(context["engine"])
            holdingTable = select context["tradeDate"], symbol, longPosition from holdingTable where longPosition > 0;
            context['holdingTableExist'] = 1

            holdingStock = exec symbol from holdingTable
            holdgNum = size(holdingStock)
            //print("ç›®å‰æŒæœ‰"+holdgNum)
        }
    }

    // 2.æ›´æ–°ä¿¡å·è¡¨ï¼ˆæä¾›ç»™ä¸‹ä¸€å¤©çš„beforeTradingï¼‰
    signalTable = table(100:5, `date`symbol`rank`value, [DATE,SYMBOL,DOUBLE,DOUBLE]);
    istockInfo = select date(tradeTime) as date, symbol as symbol, signal1 as rank, signal2 as value from msgTable
    signalTable.append!(istockInfo)
    // print("å·²æ›´æ–°ä¿¡å·")
    context['signalTable'] = signalTable
    context['signalTableExist'] = 1
}

def onOrder(mutable context,orders){}
def onTrade(mutable context,trades){}
def afterTrading(mutable context){
    holdingTable = Backtest::getPosition(context["engine"])
    // print('å½“å¤©num')
    // print(size(holdingTable))
}

def finalize(mutable context){
    // print(context['signalTable'])
    // holdingTable = Backtest::getPosition(context["engine"])
    // print(holdingTable)
    // print('num')
    // print(size(holdingTable))
    // print(context['holdingTable'])
    // availableCash = Backtest::getAvailableCash(context["engine"])
    // print(availableCash)
}

// åˆ›å»ºcallbackså‡½æ•°æ˜ å°„å…³ç³»å­—å…¸
callbacks = {
    initialize: initialize,
    beforeTrading: beforeTrading,
    onBar: onBar,
    onOrder: onOrder,
    onTrade: onTrade,
    afterTrading: afterTrading,
    finalize: finalize
}


// è®¾ç½®å›æµ‹å¼•æ“æ‰€éœ€å‚æ•°
config = {
        startDate: 2024.01.01, //å›æµ‹å¼€å§‹æ—¥æœŸ
        endDate: 2025.01.08, //å›æµ‹ç»“æŸæ—¥æœŸ
        strategyGroup: `stock, //è‚¡ç¥¨ç±»æ•°æ®
        dataType: 4, //æ—¥é¢‘
        frequency: 0, // ä¸æŠŠé€ç¬”åˆæˆå¿«ç…§
        cash: 1000000,  //ç­–ç•¥åˆå§‹èµ„é‡‘1000ä¸‡
        commission: 0.00015, // æ‰‹ç»­è´¹ç‡
        tax: 0.001, // å°èŠ±ç¨åƒåˆ†ä¹‹1
        msgAsTable: true //æ‰¹é‡è®¢é˜…
}
context = dict(STRING,ANY)
context['holdingNum'] = holdingNum
config[`context] = context

// åˆ›å»ºå›æµ‹å¼•æ“
strategyName="stockDailyStrategy"
try{Backtest::dropBacktestEngine(strategyName)}catch(ex){print ex}
engine = Backtest::createBacktester(strategyName, config, callbacks, false)
go

// æ’å…¥è¡Œæƒ…æ•°æ®ï¼ˆæ­¤ä¾‹ä¿¡å·æ•°æ®ä¸è¡Œæƒ…ä¸€èµ·ï¼‰
msg= select * from messageBar where tradeTime between 2024.01.01 15:00:00.000 and 2025.01.01 15:00:00.000
Backtest::appendQuotationMsg(engine,msg)



//æ’å…¥æœ«å°¾æ•°æ®
messageend=select top 1* from messageBar where tradeTime=max(tradeTime)
update messageend set symbol="END"
update messageend set tradeTime=concatDateTime(tradeTime.date(),16:00:00)
Backtest::appendQuotationMsg(engine,messageend)

// step 4ï¼šè·å–å›æµ‹ç»“æœ
//æˆäº¤æ˜ç»†
tradeDetails=Backtest::getTradeDetails(engine)
//æŸ¥è¯¢å½“å‰çš„æœªæˆäº¤ï¼ˆæœªå®Œæˆï¼‰è®¢å•åˆ—è¡¨
openOrders=Backtest::getOpenOrders(long(engine))
//æ¯æ—¥æŒä»“
dailyPosition=Backtest::getDailyPosition(long(engine))
//å¯ç”¨èµ„é‡‘
enableCash=Backtest::getAvailableCash(long(engine))
//æœªæˆäº¤è®¢å•æ˜ç»†
openOrders=tradeDetails[tradeDetails.orderStatus==-3]
//æ—¥ç»„åˆæŒ‡æ ‡å±•ç¤º
totalPortfolios=Backtest::getTotalPortfolios(long(engine))
//å›æµ‹ç»“æœç»¼åˆå±•ç¤º
returnSummary=Backtest::getReturnSummary(long(engine))
//è·å–ç­–ç•¥æ¯æ—¥æƒç›ŠæŒ‡æ ‡
totalPortfolios = Backtest::getDailyTotalPortfolios(engine)
//è·å–æ­¤æ—¶çš„å¼•æ“contextå˜é‡å­—å…¸
context = Backtest::getContextDict(engine)

// å‡€å€¼æ›²çº¿
plot(totalPortfolios[`netValue])

// ä¹°å–æ›²çº¿
tradesummary = select tradeTime, sum (iif(direction==1, tradePrice*tradeQty, iif(direction==3, -tradePrice*tradeQty, NULL))) from tradeDetails group by tradeTime
plot(tradesummary[`sum],date(tradesummary[`tradeTime]))

// æ”¶ç›Šç‡æ›²çº¿
plot(totalPortfolios[`totalReturn]*100)

// ä¸æ²ªæ·±300æŒ‡æ•°å¯¹æ¯”
index = loadText("/home/appadmin/zhangjiarong/daily_index.csv")
indexreturn = exec trade_date, pct_chg as index from index order by trade_date
comparetable = table(indexreturn, totalPortfolios[`ratio]*100 as `portfolio)
plot(comparetable[,1:])


// æŒ‡æ ‡å¯¹æ¯”è¡¨
ret_stats1 = exec annualReturn,  annualVolatility,sharpeRatio, maxDrawdown from returnSummary
ret_stats2 = exec 
    avg(pct_chg/100) * 252 as annual_return, 
    std(pct_chg/100) * sqrt(252.0) as annual_volatility,
    (avg(pct_chg/100) * 252) / (std(pct_chg/100) * sqrt(252.0)) as sharpe_ratio,
    -min(close / cummax(close) - 1) as drawdown
from index
comparetable2 = table(ret_stats1[0].values()$DOUBLE as `portfolio, ret_stats2[0].values()$DOUBLE as `index)
plot (comparetable2,`annualReturn`annualVolatility`sharpeRatio`maxDrawdown,,COLUMN)






